<html>
<head>
    <link rel="stylesheet" href="lib/leaflet/leaflet.css">
    <style>
        #map {
            height: 180px;
        }
    </style>
</head>
<body style="padding: 3em;">
    <p>Hello</p>
    <hr>
    <form>
        <p>
            <label for="start">Start</label>
            <input id="start" name="start" value="EGLISE D'AUTEUIL">
        </p>
        <p>
            <label for="end">End</label>
            <input id="end" name="end" value="Bel-Air">
        </p>
        <button type="button" id="find">Find</button>
    </form>
    <hr>
    <div id="errors"></div>
    <hr>
    <div id="map" class="map"></div>

    <script src="lib/binaryheap.js"></script>
    <!--<script src="lib/jquery-min.js"></script>-->
    <script src="lib/leaflet/leaflet.js"></script>
    <script src="map.js"></script>
    <script>
        var graph = {};
        var req = new XMLHttpRequest();

        window.onerror = function(msg, url, line) {
            msg = 'Error at line ' + line + ': ' + msg + ' - ' + url;
            document.getElementById('errors').innerHTML += msg;
        }

        var print = function(msg) {
            document.getElementById('errors').innerHTML += msg + '<br>';
        }

        var loadGraph = function(callback_success) {
            var date_start = new Date();

            print('Loading graph...');
            req.open('GET', 'graph_zip_semi-mini.json');
            req.onreadystatechange = function(a) {
                if( req.readyState == 4 ) {
                    if( req.status == 200) {
                        var date_end = new Date();
                        print('Graph loaded in ' + (date_end.getTime() - date_start.getTime())/1000);
                        print('Parsing graph...');
                        setTimeout( function() {
                            date_start = new Date();
                            graph = eval( '(' + req.responseText + ')');
                            date_end = new Date();
                            print('Graph parsed in ' + (date_end.getTime() - date_start.getTime())/1000);
                        }, 100);
                             
                        callback_success();
                    }
                    else {
                        console.log(a);
                        throw "Error while loading graph";
                    }
                }
            }
            req.send(null);
        }
    </script>
    <script>
        var parcours = function() {
            var start = graph['2390'];
            var q = [start];

            while(q.length > 0) {
                node = q.shift();

                print('Current station : ' + node.name);
                //console.log('Edges : ');

                node.edges.forEach( function(edge) {
                    //console.log(edge);
                    if(!graph[edge.dest].visited) {
                        if(edge.type == "1" && edge.line == "6") {
                            q.push(graph[edge.dest]);
                        }
                    }
                });

                node.visited = 1;
            }
        }

        var findNodes = function(start_name, end_name) {
            var start_node_id = null;
            var end_node_id = null;

            for(var node_id in graph) {
                var node = graph[node_id];
                if(node.name == start_name) {
                    start_node_id = node_id;
                }
                if(node.name == end_name) {
                    end_node_id = node_id;
                }
            } 

            if( start_node_id && end_node_id ) {
                return {start: start_node_id, end: end_node_id};
            }
            else {
                if( !start_node_id) {
                    print('start not found');
                }
                if( !end_node_id)
                    print('end not found');

                return false;
            }       
        }
        

        var each = function(obj, iterator, context) {
            for(var key in Object.keys(obj)) {
                iterator.call(context, obj[key], key, obj);
            }
        }
/*
        var find = function(obj, iterator, context) {
            var results = [];
            each(obj, function(value, index, list) {
                if( iterator.call(context, value, index, list )) {
                    results.push(value)
                    return true;
                }
            });
            return results;
        }

        var map = function(obj, iterator, context) {
            var results = [];
            each(obj, function(value, index, list) {
                results.push(iterator.call(context, value, index, list);
            });
            return results;
        }
*/






        var find_min = function(graph, nodes_processed, dist) {
            var min = 10000;
            var min_id = -1;

            for(var key in Object.keys(graph)) {
                if( nodes_processed[key] == 1)
                    continue;
                if( dist[key] < min ) {
                    min = dist[key];
                    min_id = key;
                }
            }

            return min_id;
        }
        

        var dijkstra = function(graph, start_id, end_id) {
            var dist = {};
            var previous = {};
            var lines = {};

            dist[start_id] = 0;

            var u_id = -1;

            var Q = new BinaryHeap(
                function(node) { return node.dist; },
                function(node) { return node.id; },
                'dist'
            );

            Object.keys(graph).forEach( function(id) {
                if( id != start_id ) {
                    Q.push( {id: id, dist: 10000} );
                    dist[id] = 10000;
                }
                else {
                    Q.push( {id: start_id, dist: 0 });
                    dist[id] = 0;
                }
            });

            //console.log('First element in Q: ', Q.content[0]);
            console.log('Q size: ', Q.size());

            var date_start = new Date();
            console.log('Dijkstra start: ')
            console.log(date_start);
            

            while( Q.size() > 0 ) {
                //find min
                u = Q.pop();
                //console.log('Popped node :');
                //console.log(u);
                u_id = u.id;
                //dist[u_id] = u.dist; //in init?

                //nodes_processed[u_id] = 1;
                //console.log('Station la plus proche non visite: ' + graph[u_id].name +', distance: ' + dist[u_id]);
                
                //end if end found or if all remaining nodes unreachable
                if(u_id == end_id) break;
                
                //relax
                graph[u_id].edges.forEach(function(edge) {
                    if( previous[u_id] 
                        && previous[u_id].line != edge.line
                        && edge.type != 4) { 
                        //console.log('Correspondance!');
                        //console.log('Edge dest id: ', edge.dest, ', Prev line :', previous[u_id].line, ', Edge line: ', edge.line, ', Edge type: ', edge.type);
                        if(edge.type == 3 && previous[u_id].type != 3) { //avg bus wait
                            delta = 1000;
                        }
                        else
                            delta = 500; //avg metro corresp + wait
                    }
                    else if( edge.type == 4 ) {
                        delta = 300; //slow down walking
                    }
                    else { delta = 0; }

                    //SHOULD NOT HAPPEN, MEANS AN EDGE REFER TO AN UNKNOWN NODE (SEE init ABOVE)
                    if(dist[edge.dest] === undefined) {
                        //console.log('WARNING, dist for ' + edge.dest + ' undefined');
                        graph[edge.dest] = {
                            name: 'unknown',
                            edges: []
                        };
                        Q.push( {id: edge.dest, dist: 10000} );
                        dist[edge.dest] = 10000;
                    }
                    
                    else if( dist[edge.dest] > dist[u_id] + edge.dur + delta) {
                        /*
                        console.log(graph[start_id].name + '--' + dist[edge.dest] + '-->' 
                            + graph[edge.dest].name + ' > ' + graph[start_id].name 
                            + '--' + dist[u_id] + '-->' + graph[u_id].name + '--' + edge.dur + '-->' + graph[edge.dest].name);
                        console.log(' ' + graph[start_id].name + ' -> ' + graph[edge.dest].name + ' = ' + (dist[u_id] + edge.dur));
                        */

                        //if( edge.line != )

                        dist[edge.dest]             = dist[u_id] + edge.dur + delta;
                        previous[edge.dest]         = {};
                        previous[edge.dest].node_id = u_id;
                        previous[edge.dest].line    = edge.line;
                        previous[edge.dest].type    = edge.type;
                        
                        Q.decreaseKey(edge.dest, dist[edge.dest]);
                    }
                });
            }

            var date_end = new Date()
            print('Duree: ' + (date_end.getTime() - date_start.getTime())/1000);

            print('Shortest path : ' + dist[end_id]);
            
            //create path
            var path = [{node_id: end_id, line: -1}];
            var prev = {node_id: end_id, line: -1};
            while(true) {
                prev = previous[prev.node_id];
                //console.log(prev);
                if(!prev) break;
                path.push(prev);
            }

            //display path
            var disp = '';
            var last_node = null;
            path.reverse();
            path.forEach( function(node, index) {
                if(index == 0) {
                    disp += 'Line: ' + node.line + ', Type: ' + node.type + ', ';
                    disp += graph[node.node_id].name;
                }
                //disp += graph[node.node_id].name
                /*
                if(last_node)
                    disp += 'Last: ' + graph[last_node.node_id].name + ' (' + last_node.node_id + '), Line: ' + last_node.line + ', Type: ' + last_node.type + '<br>';

                disp += 'Current: ' + graph[node.node_id].name + ' (' + node.node_id + '), Line: ' + node.line + ', Type: ' + node.type + '<br><br>';
                */

                if(last_node && 
                    ( (last_node.line != node.line && last_node.type != 4)
                        || (last_node.type != node.type 
                            && (last_node.type != 2 && node.type != 2) 
                            )
                    ) 
                  )
                {
                    disp += ' => ' + graph[node.node_id].name + '<br>';
                    if(last_node.type/* == 4*/) {
                        disp += 'Correspondance: ';
                        disp += last_node.type + '<br>';
                    }

                    if(node.type != 4) disp += 'Line: ' + node.line + ', Type: ' + node.type;
                    if(node.type == 4) disp += 'A pieds';
                    
                    disp += ', ' + graph[node.node_id].name;

                }

/*
                if(last_node && node.line !== last_node.line) {
                    //if(last_line !== null) {
                        disp += ' => ' + graph[last_node.node_id].name + ' (' + last_node.node_id + ')<br>';
                        if(node.line != -1) disp += 'Correspondance<br>';
                    //}
                    //if(node.line != -1 && node.type != 4) {
                        disp += 'Line: ' + node.line + ', ' + graph[node.node_id].name + ' (' + node.node_id + ')';
                    //}
                    //if(node.type == 4) {
                        //disp += 'A pattes, ' + graph[node.node_id].name + ' (' + node.node_id + ')';
                    //}
                }
*/
                last_node = node;
                //if(index > 0) disp += '-->';
                //disp += graph[node.node_id].name + ' (' + node.node_id + ')';
                //if(node.type == 4) { disp += ', a pattes'; }
                //else if(node.line) { disp += ', line: ' + node.line; }
                
            });
            print(disp);

            return path;
        }

        var findPath = function() {
            var start_name   = document.getElementById('start').value;
            var end_name     = document.getElementById('end').value;
            var start_end_nodes  = {};

            console.log('Looking for ' + start_name + ' and ' + end_name + ' in graph...');
            if(start_end_nodes = findNodes(start_name, end_name)) {
                


                var path = dijkstra(graph, start_end_nodes.start, start_end_nodes.end);
                var ratp_map = new RATPMap();
                ratp_map.showMapForPath(graph, path);
            }

        }

        var setListeners = function() {
            var button = document.getElementById('find');
            button.addEventListener('click', findPath);
        }

        setListeners();

        loadGraph(function() {});
    </script>
</body>
</html>